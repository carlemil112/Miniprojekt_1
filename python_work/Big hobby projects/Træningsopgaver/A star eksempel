import pygame
import sys
import random
from heapq import heappush, heappop

# Initialiser Pygame
pygame.init()

# Skærmstørrelse
WIDTH, HEIGHT = 800, 600
WIN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("A* Algoritme Pathfinding med Random Terræn")

# Farver
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (0, 255, 0)
BLUE = (64, 164, 223)    # Sø
GRAY = (120, 120, 120)   # Bjerg
RED = (255, 0, 0)
PURPLE = (128, 0, 128)

# Grid dimensioner
ROWS = 30
COLS = 40
GRID_WIDTH = WIDTH // COLS
GRID_HEIGHT = HEIGHT // ROWS

# Terræntyper og deres vægtninger
terrain_weights = {
    'normal': 1,
    'mountain': 5,
    'water': 10
}

class Node:
    def __init__(self, row, col, terrain='normal'):
        self.row = row
        self.col = col
        self.x = col * GRID_WIDTH
        self.y = row * GRID_HEIGHT
        self.terrain = terrain
        self.color = WHITE
        self.neighbors = []
        self.cost = terrain_weights[terrain]
        self.parent = None
        self.update_color()

    def update_color(self):
        if self.terrain == 'normal':
            self.color = WHITE
        elif self.terrain == 'mountain':
            self.color = GRAY
        elif self.terrain == 'water':
            self.color = BLUE

    def draw(self, win):
        pygame.draw.rect(win, self.color, (self.x, self.y, GRID_WIDTH, GRID_HEIGHT))

    def update_neighbors(self, grid):
        self.neighbors = []
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # op, ned, venstre, højre
        for dir in directions:
            row = self.row + dir[0]
            col = self.col + dir[1]
            if 0 <= row < ROWS and 0 <= col < COLS:
                neighbor = grid[row][col]
                self.neighbors.append(neighbor)

def heuristic(a, b):
    # Manhattan distance
    return abs(a.row - b.row) + abs(a.col - b.col)

def reconstruct_path(current, draw):
    while current.parent:
        current = current.parent
        if current.parent:  # Undgå at farve startnoden
            current.color = PURPLE
        draw()

def a_star(draw, grid, start, end):
    count = 0
    open_set = []
    heappush(open_set, (0, count, start))

    g_score = {node: float('inf') for row in grid for node in row}
    g_score[start] = 0

    f_score = {node: float('inf') for row in grid for node in row}
    f_score[start] = heuristic(start, end)

    open_set_hash = {start}

    while open_set:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        current = heappop(open_set)[2]
        open_set_hash.remove(current)

        if current == end:
            reconstruct_path(end, draw)
            end.color = GREEN
            start.color = GREEN
            return True

        for neighbor in current.neighbors:
            temp_g_score = g_score[current] + neighbor.cost

            if temp_g_score < g_score[neighbor]:
                neighbor.parent = current
                g_score[neighbor] = temp_g_score
                f_score[neighbor] = temp_g_score + heuristic(neighbor, end)
                if neighbor not in open_set_hash:
                    count += 1
                    heappush(open_set, (f_score[neighbor], count, neighbor))
                    open_set_hash.add(neighbor)
                    neighbor.color = RED

        draw()

        if current != start:
            current.update_color()

    return False

def make_grid():
    grid = []
    for row in range(ROWS):
        grid.append([])
        for col in range(COLS):
            node = Node(row, col)
            grid[row].append(node)
    return grid

def generate_random_terrain(grid):
    for row in grid:
        for node in row:
            terrain_choice = random.choices(
                ['normal', 'mountain', 'water'],
                weights=[70, 20, 10],
                k=1
            )[0]
            node.terrain = terrain_choice
            node.cost = terrain_weights[terrain_choice]
            node.update_color()

def draw_grid(win):
    for row in range(ROWS):
        pygame.draw.line(win, BLACK, (0, row * GRID_HEIGHT), (WIDTH, row * GRID_HEIGHT))
    for col in range(COLS):
        pygame.draw.line(win, BLACK, (col * GRID_WIDTH, 0), (col * GRID_WIDTH, HEIGHT))

def draw(win, grid):
    win.fill(WHITE)
    for row in grid:
        for node in row:
            node.draw(win)

    draw_grid(win)
    pygame.display.update()

def get_clicked_pos(pos):
    x, y = pos
    row = y // GRID_HEIGHT
    col = x // GRID_WIDTH
    return row, col

def main(win):
    grid = make_grid()
    generate_random_terrain(grid)

    start = None
    end = None

    run = True
    started = False

    while run:
        draw(win, grid)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

            if started:
                continue

            if pygame.mouse.get_pressed()[0]:  # Venstre klik
                pos = pygame.mouse.get_pos()
                row, col = get_clicked_pos(pos)
                if row >= ROWS or col >= COLS:
                    continue
                node = grid[row][col]
                if not start and node != end:
                    start = node
                    start.color = GREEN
                elif not end and node != start:
                    end = node
                    end.color = GREEN

            elif pygame.mouse.get_pressed()[2]:  # Højre klik
                pos = pygame.mouse.get_pos()
                row, col = get_clicked_pos(pos)
                if row >= ROWS or col >= COLS:
                    continue
                node = grid[row][col]
                if node == start:
                    start = None
                    node.update_color()
                elif node == end:
                    end = None
                    node.update_color()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and start and end:
                    for row in grid:
                        for node in row:
                            node.update_neighbors(grid)

                    started = True
                    a_star(lambda: draw(win, grid), grid, start, end)
                    started = False

                if event.key == pygame.K_c:
                    start = None
                    end = None
                    grid = make_grid()
                    generate_random_terrain(grid)

                if event.key == pygame.K_r:
                    start = None
                    end = None
                    grid = make_grid()
                    generate_random_terrain(grid)

    pygame.quit()

main(WIN)
