import pygame
import heapq

# Farver
WHITE = (255, 255, 255)
GREEN = (0, 255, 0)  # Græs
BLUE = (0, 0, 255)   # Vand
BROWN = (139, 69, 19)  # Bjerg
BLACK = (0, 0, 0)    # Væg
RED = (255, 0, 0)    # Sti (Path)

# Pygame setup
WIDTH = 700
HEIGHT = 500
CELL_SIZE = 100
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("A* Pathfinding Visualization")

# Node class to store position, g, h, f and parent
class Node:
    def __init__(self, position, parent=None, g=0, h=0, f=0):
        self.position = position
        self.parent = parent
        self.g = g  # Cost from start to node
        self.h = h  # Heuristic cost (estimate to goal)
        self.f = f  # Total cost (g + h)

    def __eq__(self, other):
        return self.position == other.position

    def __lt__(self, other):
        return self.f < other.f

# A* algorithm
def a_star_algorithm(grid, start, goal):
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
    open_list = []
    closed_list = []
    start_node = Node(start)
    goal_node = Node(goal)
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        closed_list.append(current_node)

        if current_node == goal_node:
            path = []
            while current_node is not None:
                path.append(current_node.position)
                current_node = current_node.parent
            return path[::-1]

        for direction in directions:
            neighbor_pos = (current_node.position[0] + direction[0], current_node.position[1] + direction[1])
            if neighbor_pos[0] < 0 or neighbor_pos[0] >= len(grid) or neighbor_pos[1] < 0 or neighbor_pos[1] >= len(grid[0]):
                continue
            if grid[neighbor_pos[0]][neighbor_pos[1]] == 'W':
                continue
            g_cost = current_node.g + grid[neighbor_pos[0]][neighbor_pos[1]]
            h_cost = abs(neighbor_pos[0] - goal_node.position[0]) + abs(neighbor_pos[1] - goal_node.position[1])
            neighbor_node = Node(neighbor_pos, current_node, g_cost, h_cost, g_cost + h_cost)

            if neighbor_node in closed_list:
                continue
            if any(open_node for open_node in open_list if open_node == neighbor_node and open_node.g < neighbor_node.g):
                continue
            heapq.heappush(open_list, neighbor_node)

    return None

# Function to draw the grid and the path
def draw_grid(screen, grid, path):
    colors = {
        1: GREEN,
        'W': BLACK,
    }

    for x in range(len(grid)):
        for y in range(len(grid[0])):
            color = colors.get(grid[x][y], WHITE)
            pygame.draw.rect(screen, color, pygame.Rect(y * CELL_SIZE, x * CELL_SIZE, CELL_SIZE, CELL_SIZE))
            pygame.draw.rect(screen, WHITE, pygame.Rect(y * CELL_SIZE, x * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)

    if path:
        for position in path:
            pygame.draw.rect(screen, RED, pygame.Rect(position[1] * CELL_SIZE, position[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))

# Hardcoded map
grid = [
    [1, 1, 1, 'W', 1, 1, 1],
    [1, 'W', 1, 'W', 1, 'W', 1],
    [1, 1, 1, 'W', 1, 1, 1],
    [1, 'W', 1, 'W', 1, 'W', 1],
    [1, 1, 1, 1, 1, 1, 1],
]

start = (0, 0)
goal = (4, 6)

path = a_star_algorithm(grid, start, goal)

# Main game loop
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill(WHITE)
    draw_grid(screen, grid, path)
    pygame.display.flip()

pygame.quit()
